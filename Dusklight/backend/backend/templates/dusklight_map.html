<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Golden Hour Photo</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
    <style>
        body {
            background: linear-gradient(120deg, #232526 0%, #414345 100%);
            color: #f3f3f3;
            font-family: 'Segoe UI', 'Arial', sans-serif;
            margin: 0;
            padding: 0;
        }
        #map {
            height: 70vh;
            width: 100%;
            border-radius: 12px;
            box-shadow: 0 4px 24px rgba(0,0,0,0.3);
            margin-bottom: 2em;
        }
        .leaflet-container {
            background: #222;
            border-radius: 12px;
        }
        form#sunset-form {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 1em;
            background: rgba(30, 30, 40, 0.85);
            padding: 1em 2em;
            border-radius: 10px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
            margin: 2em auto 1em auto;
            max-width: 600px;
        }
        form#sunset-form label {
            font-size: 1.1em;
            color: #f3f3f3;
        }
        form#sunset-form input[type="date"] {
            background: #232526;
            color: #f3f3f3;
            border: 1px solid #444;
            border-radius: 5px;
            padding: 0.3em 0.7em;
            font-size: 1em;
        }
        form#sunset-form button {
            background: linear-gradient(90deg, #ffb347 0%, #ffcc33 100%);
            color: #232526;
            border: none;
            border-radius: 5px;
            padding: 0.5em 1.2em;
            font-size: 1.1em;
            font-weight: bold;
            cursor: pointer;
            transition: background 0.2s, color 0.2s;
        }
        form#sunset-form button:hover {
            background: linear-gradient(90deg, #ffcc33 0%, #ffb347 100%);
            color: #232526;
        }
        #sunset-time-info, #alignment-info {
            text-align: center;
            font-size: 1.15em;
            margin-bottom: 1em;
            padding: 0.5em 1em;
            border-radius: 8px;
            max-width: 600px;
            margin-left: auto;
            margin-right: auto;
        }
        #sunset-time-info {
            background: rgba(0, 160, 255, 0.12);
            color: #0af;
            border: 1px solid #0af2;
        }
        #alignment-info {
            background: rgba(255, 180, 70, 0.10);
            color: orange;
            border: 1px solid #ffb34744;
        }
        a {
            color: #ffb347;
            text-decoration: underline;
            transition: color 0.2s;
        }
        a:hover {
            color: #fff;
        }
        #loading-overlay {
            display: none;
            position: fixed;
            top: 0; left: 0;
            width: 100vw; height: 100vh;
            background: rgba(30,30,40,0.7);
            z-index: 9999;
            align-items: center;
            justify-content: center;
            flex-direction: column;
        }
        .loader {
            border: 8px solid #f3f3f3;
            border-top: 8px solid #ffb347;
            border-radius: 50%;
            width: 70px;
            height: 70px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        @media (max-width: 700px) {
            form#sunset-form {
                flex-direction: column;
                gap: 0.5em;
                padding: 1em;
            }
            #map {
                height: 50vh;
            }
        }
    </style>
</head>
<body>
    <form id="sunset-form">
        <label>Date: <input type="date" id="date"></label>
        <label>Sun degree above horizon:
            <select id="sun-altitude-filter">
                <option value="-2,2">Near horizon (-2° to 2°)</option>
                <option value="2,10">Low (2° to 10°)</option>
                <option value="10,90">High (&gt;10°)</option>
                <option value="-90,90">Any</option>
            </select>
        </label>
        <button type="submit">Show Sunset Streets</button>
    </form>
    <div id="map"></div>
    <div id="sunset-time-info"></div>
    <div id="alignment-info"></div>
    <div id="loading-overlay" style="display:none;position:fixed;top:0;left:0;width:100vw;height:100vh;background:rgba(30,30,40,0.7);z-index:9999;align-items:center;justify-content:center;flex-direction:column;">
        <div class="loader"></div>
        <button id="cancel-loading" style="margin-top:2em;padding:0.7em 2em;font-size:1.1em;border-radius:8px;border:none;background:#ffb347;color:#232526;font-weight:bold;cursor:pointer;">Cancel</button>
    </div>
    <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
    <script src="https://unpkg.com/axios/dist/axios.min.js"></script>
    <script>
    // Helper: retry axios POST request up to 3 times
    async function axiosPostWithRetry(url, data, maxRetries = 3, delay = 500) {
        let lastError;
        for (let attempt = 0; attempt < maxRetries; attempt++) {
            try {
                return await axios.post(url, data);
            } catch (e) {
                lastError = e;
                if (attempt < maxRetries - 1) {
                    await new Promise(res => setTimeout(res, delay));
                }
            }
        }
        throw lastError;
    }

    // Set default date to today
    document.addEventListener('DOMContentLoaded', function() {
        var dateInput = document.getElementById('date');
        if (dateInput) {
            var today = new Date();
            var yyyy = today.getFullYear();
            var mm = String(today.getMonth() + 1).padStart(2, '0');
            var dd = String(today.getDate()).padStart(2, '0');
            dateInput.value = yyyy + '-' + mm + '-' + dd;
        }
        // Show sunset time for today at map center
        showSunsetTime();
    });

    // Show sunset time for selected date and map center
    async function showSunsetTime() {
        const date = document.getElementById('date').value;
        const center = map.getCenter();
        let infoDiv = document.getElementById('sunset-time-info');
        infoDiv.textContent = 'Loading sunset time...';
        try {
            const resp = await axiosPostWithRetry('/api/sunset-azimuth/', {
                latitude: center.lat,
                longitude: center.lng,
                date: date
            });
            if (resp.data && resp.data.sunset) {
                // Convert UTC sunset time to local time
                const utcTime = resp.data.sunset;
                // Build a Date object for the selected date and UTC time
                const [h, m] = utcTime.split(":");
                const dateObj = new Date(date + 'T' + h.padStart(2, '0') + ':' + m.padStart(2, '0') + ':00Z');
                const localTime = dateObj.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
                infoDiv.textContent = `Sunset at this location: ${localTime} (your local time)`;
            } else if (resp.data && resp.data.error) {
                infoDiv.textContent = 'Error: ' + resp.data.error;
            } else {
                infoDiv.textContent = 'Sunset time unavailable.';
            }
        } catch (e) {
            infoDiv.textContent = 'Error fetching sunset time.';
        }
    }

    // Set up map
    var defaultLat = 40.7128;
    var defaultLng = -74.0060;
    var map = L.map('map').setView([defaultLat, defaultLng], 14);
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        maxZoom: 19,
        attribution: '© OpenStreetMap'
    }).addTo(map);

    // Try to focus map on user location
    if (navigator.geolocation) {
        navigator.geolocation.getCurrentPosition(function(position) {
            var userLat = position.coords.latitude;
            var userLng = position.coords.longitude;
            map.setView([userLat, userLng], 15);
        });
    }

    var streetLayers = [];
    var abortHighlight = { cancel: false };

    // Helper to fetch and highlight streets
    async function highlightSunsetStreets(lat, lng, date) {
        // Show loading overlay
        abortHighlight.cancel = false;
        document.getElementById('loading-overlay').style.display = 'flex';
        // Get sunset azimuth from backend
        let azimuth = null;
        try {
            const resp = await axiosPostWithRetry('/api/sunset-azimuth/', { latitude: lat, longitude: lng, date: date });
            azimuth = resp.data.azimuth;
        } catch (e) {
            alert('Error fetching sunset azimuth');
            document.getElementById('loading-overlay').style.display = 'none';
            return;
        }
        // Get sun altitude filter
        const sunAltFilter = document.getElementById('sun-altitude-filter').value.split(',').map(Number);
        // Fetch OSM streets (GeoJSON)
        async function fetchStreetsWithRetry(query, maxRetries = 3, delay = 1000) {
            let lastError;
            for (let attempt = 0; attempt < maxRetries; attempt++) {
                try {
                    const resp = await axios.post(overpassUrl, query, { headers: { 'Content-Type': 'text/plain' } });
                    return resp.data;
                } catch (e) {
                    lastError = e;
                    if (attempt < maxRetries - 1) {
                        await new Promise(res => setTimeout(res, delay));
                    }
                }
            }
            return null;
        }
        const overpassUrl = 'https://overpass-api.de/api/interpreter';
        const query = `[
            out:json][timeout:25];
            (
              way["highway"](around:1000,${lat},${lng});
            );
            out geom;`;
        let geojson = await fetchStreetsWithRetry(query);
        if (!geojson) {
            document.getElementById('loading-overlay').style.display = 'none';
            return;
        }
        // Remove previous layers
        streetLayers.forEach(function(layer) { map.removeLayer(layer); });
        streetLayers = [];
        map.eachLayer(function(layer) {
            if (layer instanceof L.Polyline && !(layer instanceof L.TileLayer)) {
                map.removeLayer(layer);
            }
        });
        // Batch helpers so we only hit the backend a few times
        async function getSunAlignedTimesBatch(requests) {
            try {
                const resp = await axiosPostWithRetry('/api/sun-aligned-time-batch/', { items: requests });
                return resp.data.results;
            } catch {
                return requests.map(() => ({ times: [] }));
            }
        }
        async function getSunAltitudesBatch(requests) {
            try {
                const resp = await axiosPostWithRetry('/api/sun-altitude-batch/', { items: requests });
                return resp.data.results;
            } catch {
                return requests.map(() => null);
            }
        }
        const segmentData = [];
        const alignRequests = [];
        for (const way of (geojson.elements || [])) {
            if (abortHighlight.cancel) break;
            if (way.type === 'way' && way.geometry && way.geometry.length > 1) {
                for (let i = 1; i < way.geometry.length; i++) {
                    if (abortHighlight.cancel) break;
                    const p1 = way.geometry[i - 1];
                    const p2 = way.geometry[i];
                    const bearing = Math.atan2(
                        Math.sin((p2.lon - p1.lon) * Math.PI / 180) * Math.cos(p2.lat * Math.PI / 180),
                        Math.cos(p1.lat * Math.PI / 180) * Math.sin(p2.lat * Math.PI / 180) -
                        Math.sin(p1.lat * Math.PI / 180) * Math.cos(p2.lat * Math.PI / 180) * Math.cos((p2.lon - p1.lon) * Math.PI / 180)
                    ) * 180 / Math.PI;
                    const bearingNorm = (bearing + 360) % 360;
                    const diff = Math.abs(bearingNorm - azimuth);
                    if (!(diff < 10 || diff > 350)) continue;
                    alignRequests.push({
                        latitude: (p1.lat + p2.lat) / 2,
                        longitude: (p1.lon + p2.lon) / 2,
                        date: date,
                        bearing: bearingNorm
                    });
                    segmentData.push({ p1, p2, bearingNorm });
                }
            }
        }
        const alignResults = await getSunAlignedTimesBatch(alignRequests);
        const altitudeRequests = [];
        const altitudeIndexMap = segmentData.map(() => -1);
        for (let idx = 0; idx < segmentData.length; idx++) {
            const alignmentTimes = (alignResults[idx] && alignResults[idx].times) || [];
            segmentData[idx].alignmentTimes = alignmentTimes;
            if (alignmentTimes.length > 0) {
                altitudeIndexMap[idx] = altitudeRequests.length;
                altitudeRequests.push({
                    latitude: (segmentData[idx].p1.lat + segmentData[idx].p2.lat) / 2,
                    longitude: (segmentData[idx].p1.lon + segmentData[idx].p2.lon) / 2,
                    date: date,
                    time: alignmentTimes[0]
                });
            }
        }
        const altitudeResults = await getSunAltitudesBatch(altitudeRequests);
        for (let idx = 0; idx < segmentData.length; idx++) {
            const { p1, p2, bearingNorm, alignmentTimes } = segmentData[idx];
            if (!alignmentTimes || alignmentTimes.length === 0) continue;
            const altitudeIdx = altitudeIndexMap[idx];
            const altitude = altitudeIdx === -1 ? null : altitudeResults[altitudeIdx] && altitudeResults[altitudeIdx].altitude;
            if (altitude === null || altitude === undefined || altitude < sunAltFilter[0] || altitude > sunAltFilter[1]) {
                continue;
            }
            var color = 'orange';
            var weight = 5;
            var poly = L.polyline([
                [p1.lat, p1.lon],
                [p2.lat, p2.lon]
            ], { color: color, weight: weight, opacity: 0.8, className: 'street-segment' })
            .addTo(map)
            .on('click', async function(e) {
                var midLat = (p1.lat + p2.lat) / 2;
                var midLon = (p1.lon + p2.lon) / 2;
                const date = document.getElementById('date').value;
                let sunsetAz = null;
                try {
                    const resp = await axios.post('/api/sunset-azimuth/', { latitude: midLat, longitude: midLon, date: date });
                    sunsetAz = resp.data.azimuth;
                } catch (e) {
                    sunsetAz = bearingNorm;
                }
                var svUrl = `https://www.google.com/maps?q=&layer=c&cbll=${midLat},${midLon}&cbp=0,${sunsetAz},0,0,0`;
                var popupHtml = `<div><b>Street View toward sunset</b><br><a href='${svUrl}' target='_blank' rel='noopener'>Open in Google Street View</a></div>`;
                L.popup().setLatLng([midLat, midLon]).setContent(popupHtml).openOn(map);
            });
            streetLayers.push(poly);
        }
        document.getElementById('loading-overlay').style.display = 'none';
    }

    document.getElementById('sunset-form').onsubmit = function(e) {
        e.preventDefault();
        document.getElementById('alignment-info').textContent = '';
        const date = document.getElementById('date').value;
        const center = map.getCenter();
        const lat = center.lat;
        const lng = center.lng;
        highlightSunsetStreets(lat, lng, date);
    };
    document.getElementById('date').addEventListener('change', function() {
        showSunsetTime();
    });
    document.getElementById('sun-altitude-filter').addEventListener('change', function() {
        const date = document.getElementById('date').value;
        const center = map.getCenter();
        highlightSunsetStreets(center.lat, center.lng, date);
    });
    map.on('moveend', function() {
        showSunsetTime();
    });
    document.getElementById('cancel-loading').onclick = function() {
        abortHighlight.cancel = true;
        document.getElementById('loading-overlay').style.display = 'none';
    };
    </script>
</body>
</html>
